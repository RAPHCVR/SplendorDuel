@startuml
'skinparam classAttributeIconSize 0

enum Niveau <<enumeration >> {
  1
  2
  3
}

struct Bonus {
    couleur : TokenColor
    nombre : uint
}

enum TokenColor <<enumeration >> {
  BLANC
  VERT
  PERLE
  BLEU
  OR
  ROUGE
  NOIR
}
enum OptionalActions{
    UsePrivileges, FillBoard, Empty
}

enum CompulsoryActions{
    TakeCoins, ReserveCard, BuyCard
}

namespace JetonsPrivilegePlateau {

class Token {
   -couleur : TokenColor
   +Token(jeton : const Token)
   +Token(couleur: TokenColor)
   +getCouleur() : TokenColor
}

class Privilege{
}

class Bag{
  -jetons : Liste[Token]
  -Bag(total : const TokenTotaux)
  +getNbJetons() : size_t
  +addJeton(jeton : const Token)
  +PiocherJeton() : const Token
  +estVide() : bool
  +getInstance() : Bag
  +containsOnly(color : TokenColor) : bool
}
note bottom of Bag : Le sac de jeton est unique, pas de duplication

class JetonsTotaux{
   -jetons : Liste[Token]
   -max_or : const size_t
   -max_rouge : const size_t
   -max_noir : const size_t
   -max_bleu : const size_t
   -max_perle : const size_t
   -max_vert : const size_t
   -max_blanc : const size_t
   {fi+TokenTotaux()
   +~TokenTotaux
   +getNbJetons : size_t
   +getJeton : const Token
}
note bottom of JetonsTotaux: Le total initial est unique, pas de duplication

class PrivilegesTotaux{
   -privileges : Liste[Privilege]
   -PrivilegesTotaux()
   -~PrivilegesTotaux()
   +getNbPrivileges() : size_t
   +getPrivilege() : const Privilege
   +getInstance() : TotalPrivilege
}
note bottom of PrivilegesTotaux: pas de duplication du total

class Plateau{
   -tokens : Liste[Liste[Token]]
   -privileges : Liste[Privilege]
   -observers : vecteur[Observer]
   +Plateau(sac: Bag, privileges: const PrivilegesTotaux)
   +takeToken(i : size_t, j : size_t) : const Token
   +showBoard()
   +takePrivilege() : const Privilege
   +placerJeton(jeton : const Token)
   +placerPrivilege(privilege : const Privilege)
   +remplirPlateau(sac: Bag)
   +estVideo() : bool
   +getInstance() : Plateau
   + class PlateauIterateur
}
note bottom of Plateau: pas de duplication du plateau


' struct TupleIntJeton {
'   nombre : int
'   type_jeton : Token
' }

'class CoordonneeJeton{
'  x : int
'  y : int
'}
}

enum Abilities <<enumeration >> {
  Rejouer
  Prendre_privilege
  Prendre_jeton_adversaire
  Prendre_jeton_plateau
  Cameleon
}
namespace GestionPartie{

class Controller {
  - Game : Game
  - JoueurEnCours : JoueurEnCours
}			 
class Game{
    -GameTable : GameTable
								 
    -joueur_courant : Player
    -tour : uint
						 
					   
}
class GameTable{
    - plateau : Plateau
    - sac : Bag
    - cartes_pyramide : CartesPyramide
    - cartes_royales : Liste[RoyalCard]
    - cartes_joaillerie : Liste[JewelryCard]
    -DeckNv(1 à 3) : DeckNv(1 à 3)
								  
}

class QTGame {
    - controller: Controller*
    - plateView: PlateView*
    - pyramid: QTPyramid*
    - pioches: QTRangeePioches*
    - boardRoyal: QTBoardRoyal*
    - privilegeCounter: PrivilegeCounter*
    - mainlayout: QVBoxLayout*
    - screen: QScreen*
    - size: QSize*
    - player1: PlayerQT*
    - player2: PlayerQT*
    - width: unsigned int
    - height: unsigned int
    - status: std::string
    + quit(): void
    + paintEvent(event: QPaintEvent*): void
    + QTGame(parent: QWidget = nullptr)
    + handleTokenSelection(tokens: std::vector<const Token*>): void
    + fillBoard(): void
    + takePrivilege(player: Player&): void
    + bookCard(gametable: GameTable&): void
    + usePriviledge(): void
    + placePrivilege(nb: unsigned int): void
    + applyOptionalAction(action: OptionalActions): void
    + play(): void
    + playOptionalActions(): void
    + handleGameStatus(): void
    + playCompulsoryActions(): void
    + applyCompulsoryAction(action: CompulsoryActions): void
    + checkEndTurn(): void
    + applyCardSkills(game: Game, cardOwner: Player, opponent: Player, card: JewelryCard): void
    + buyJewelryCard(gametable: GameTable): void
    + buyNobleCard(): void
    + applyRoyalCardSkills(game: Game, cardOwner: Player, opponent: Player, card: RoyalCard): void
    + setBoldCurrentPlayer(): void
    + generateNewGame(): void
    + handleBuyingJewelryCard(cardclicked: Carte*): void
    + handleBookingJewelryCardFromPyramid(clickedCard: Carte*): void
    + handleBookingJewelryCardFromPioche(piocheclicked: QTPioche*): void
    + handleBuyingRoyalCard(cardclicked: QTCardRoyal*): void
    + handleBuyingReserveCard(clickedCard: JewelryCard*): void
}

class QTStartingMenu {
    + QTStartingMenu(parent: QWidget = nullptr)
    + getPlayerName1(): QString
    + getPlayerName2(): QString

private:
    - playerName1: QString
    - playerName2: QString

public slots:
    + startNewGame(): void
    + loadGame(): void
    + quitGame(): void
}

}
namespace JoueurHumainIA {

enum Type <<enumeration >> {
  IA
  Humain
}

class Player {
  - name : string
  - privileges : Liste[Privilege*]
  - type : Type
  - nbCrown : int
  - prestigePoints : int
  - nbTokens : int
  - jewelryCards : Liste[JewelryCard*]
  - reserve : Liste[JewelryCard*]
  - royalCards : Liste[RoyalCard*]
  - tokens: unordered_map[int, [Liste[const Token*]]
  - tokenSummary: unordered_map[TokenColor, int]
  - blueSummary: SummaryCard
  - greenSummary: SummaryCard
  - redSummary: SummaryCard
  - whiteSummary: SummaryCard
  - blackSummary: SummaryCard
  - strategy : Strategy*

  + getName() : string
  + getNbPrivilege() const : int
  + getNbTokens() const : int
  + getTokenSummary(): unordered_map<TokenColor, int>
  + getBonusSummary() : vector
  + getColorSummary() : SummaryCard&
  + getWhiteSummary():SummaryCard&
  + getGreenSummary():SummaryCard&
  + getBlackSummary():SummaryCard&
  + getRedSummary() :SummaryCard&
  + getMaxPrestigeColor() : int
  + getPrivilege() : int
  + getPrestige() : int
  + getCrowns() : int
  + getTokens() : int
  + getType() : Type
  + addToken(Token token)
  + removeToken(Token token)
  + addCrowns()
  + addPrestige(int nb, TokenColor couleur)
  + addPrivilege(const Privilege& privilege)
  + removePrivilege()
  + addJewelryCard(JewelryCard card)
  + addRoyalCard(RoyalCard card)
  + actionAddToken()
  + actionReserveCard()
  + actionBuyCard()
  + actionBuyReservedCard(JewelryCard &card)											
  + canBuyCard(const JewelryCard &card): Bool
  + spendResources(const JewelryCard &card)
  + usePrivilege()
  + reserveoneCard (JewelryCard& card)
  + canReserveCard()									  
  + actionFillBoard()
  + canbuyreservedcard() : bool
  + spendGoldTokens(int number) : void
  + spendSpecificToken(TokenColor color, int number) : void
  + toString(Type t) : string
  + toType(string s) : Type
  + operator<<(std::ostream& f, Player& p) : ostream&
  + getStrategy() : Strategy*
}
note bottom of Player : privilege entre 0 et 3


class Strategy

class AiStrategy{
    + choicemaker(int min, int max) : int 
    + choseOptionalActions() : std::vector<OptionalActions> 
    + choseCompulsoryAction() : CompulsoryActions 
    + choseTokensToTake() : std::vector<std::pair<int, int>> 
    + choseTokenColor(std::vector<TokenColor>& chosableColors) : TokenColor 
    + chooseToken(Board&board,Player &player, std::vector<std::pair<int, int>>* tokenIndexes=nullptr) : const Token&
    + chooseGoldenToken(Board&board, Player&player): void 

}

class HumanStrategy{
    + choicemaker(int min, int max) : int 
    + choseOptionalActions() : std::vector<OptionalActions> 
    + choseCompulsoryAction() : CompulsoryActions 
    + choseTokensToTake() : std::vector<std::pair<int, int>> 
    + choseTokenColor(std::vector<TokenColor>& chosableColors) : TokenColor 
    + chooseToken(Board&board,Player &player, std::vector<std::pair<int, int>>* tokenIndexes=nullptr) : const Token&
    + chooseGoldenToken(Board&board, Player&player): void 

}


}

namespace GestionCartes{

class JewelryCard <<abstract>>{
  - niveau : uint
  - bonus : Bonus
  - point_de_prestige : uint
  - capacite : Abilities
  - {field} cout : Liste[int]
  - couronne : int
  - id : int
  +JewelryCard(niveau : Niveau, bonus : TokenColor, point_de_prestige : int, capacite : Abilities, cout : Liste[int], couronne : int, id : int)
  +getNiveau() : int
  +getBonus() : Bonus
  +getCompetence1() : Abilities
  +getCompetence2() : Capactie
  +getPrestige() : int
  +getCout() : Liste[int]
  +getCouronne() : int
  +getId() : int
}
note bottom of JewelryCard : point de prestige entre 0 et 4\ncouronne entre 0 et 2


class RoyalCard {
  - point_de_prestige : uint
  - capacite : Abilities
  - id : int
  + RoyalCard(point_de_prestige : int, capacite : Abilities)
  + getPrestige() : uint
  + getCompetence() : Abilities
  + getId() : int
}
note bottom of RoyalCard :  point de prestige 2 ou 3\ncouronnes nécessaire entre 3 ou 6
note bottom of RoyalCard : Une classe RoyalCardError est présente pour spécifier les erreurs

class Deck_Royal{
  - Deck_Royal()
  - instance : Deck_Royal
  - cards : vecteur[RoyalCard]
  + getInstance : Deck_Royal
  + getCards : vecteur[RoyalCard]
  + addCardToDeck(card : RoyalCard) : void
  + deleteCard(pos : int) : void
}
note bottom of Deck_Royal : Gère le deck des cartes royales

class DeckNv1{
  - Deck_level_one()
  - instance : Deck_level_one 
  - pioche : Liste[RoyalCard]
  + getInstance() : Deck_level_one
  + getPioche() : Liste[RoyalCard]
  + addCardToDeck(card : RoyalCard) : void
  + deleteFirstItem() : void
}

class DeckNv2{
  - Deck_level_two()
  - instance : Deck_level_two 
  - pioche : Liste[RoyalCard]
  + getInstance() : Deck_level_two
  + getPioche() : Liste[JewelryCard]
  + addCardToDeck(card : JewelryCard) : void
  + deleteFirstItem() : void
}

class DeckNv3{
  - Deck_level_three()
  - instance : Deck_level_three
  - pioche : Liste[JewelryCard]
  + getInstance() : Deck_level_three
  + getPioche() : Liste[JewelryCard]
  + addCardToDeck(card : JewelryCard) : void
  + deleteFirstItem() : void
}

class CartesPyramide{
    - instance : CartesPyramide
    - niveau1 : Liste[JewelryCard]
    - niveau2 : Liste[JewelryCard]
    - niveau3 : Liste[JewelryCard]
    - max_level_one : static int
    - max_level_two : static int
    - max_level_three : static int
    + getInstance() : CartesPyramide
    + CartesPyramide(deck1 : DeckNv1, deck2 : DeckNv2, deck3 : DeckNv3)
    + piocherCarte(niveau : uint) : const JewelryCard
    + remplirPyramide(deck1 : DeckNv1, deck2 : DeckNv2, deck3 : DeckNv3)
    + isEmpty(level : int) : bool
    + getLevelCards(i : int) : vecteur[JewelryCard]
}

class QTCartes {
    + //enum CardStatus {
    //    BUYABLE
    //    RESERVABLE
    //    NOTCLICKABLE
    //}
    - jewelryCard: JewelryCard
    - status: CardStatus
    - getImagePath(): QString
    + getstatus() : CardStatus
    + setStatus(newStatus : CardStatus) : void
    + QTCartes(JewelryCard : JewelryCard, parent : QWidget)
    + ~Carte()
    +afficher() : void
    + getJewelryCard() : JewelryCard
    + isCardBuyable(carte : QTCard) : bool
    + isCardReservable(carte : QTCard) : bool
    + mousePressEvent(event : QMouseEvent) : void
    + clicked(carte : QTCartes) : void

}

class QTPyramid {

    - cartes_pyramide: pyramidcard
    - grille : QGridLayout
    - ajoutercarte(row : int, col : int): void
    + QTPyramid(parent : QWidget)
    + ~QTPyramid()
    + afficher() : void
    + getPyramidCard() : cartes_pyramide
    + ajoutercarte(rowlevel : int) : void
    + retirerCarte(carte : QTCartes) : int
    + carteClicked(carte : QTCartes) : void
    + updateallcardstatus(newstatus : QTCartes::CardStatus) : void
    + acheterCarteClicked(carte : QTCartes) : void
    + reserverCarteClicked(carte : QTCartes) : void

}

class QTPioche {

    - Deck1 : Deck_level_one
    - Deck2 : Deck_level_two
    - Deck3 : Deck_level_three
    - status : PiocheStatus
    - getImagePath() : QString
    + //enum PiocheStatus{
    //reservable
    //notclickable
    //}
    + getstatus() : PiocheStatus
    + setStatus((newStatus : PiocheStatus) : void
    + QTPioche(Deck1 : Deck_level_one, Deck2 : Deck_level_two, Deck3 : Deck_level_three)
    + ~QTPioche()
    + afficher ()
    + getDeck1 :  Deck_level_one
    + getDeck2 :  Deck_level_two
    + getDeck3 :  Deck_level_three
    + isCardReservable(pioche : QTPioche) : bool
    + mousePressEvent(event : QMouseEvent)
    + clicked(pioche : QTPioche) : void
}

class QTRangeePioches {
    - grille: QGridLayout
    - ajouterPioche(row: int, col: int): void
    + QTRangeePioches(parent: QWidget = nullptr)
    + afficher(): void
    + getGrid(): QGridLayout*
    + piocheClicked(pioche: QTPioche*): void
    + updateAllPiocheStatus(newStatus: QTPioche::PiocheStatus): void
    + reserverCarteClicked(pioche: QTPioche*): void
}

class QTCardRoyal {
    - royalcard: RoyalCard
    - status: CardRoyalStatus
    - getImagePath(): QString
    + //enum CardRoyalStatus {
    //    BUYABLE
    //    NOTCLICKABLE
    //}
    + QTCardRoyal(rc: RoyalCard, parent: QLabel = nullptr)
    + ~QTCardRoyal()
    + afficher(): void
    + getRoyalCard(): RoyalCard*
    + isCardBuyable(card: QTCardRoyal): bool
    + mousePressEvent(event: QMouseEvent): void
    + clicked(carte: QTCardRoyal): void
}

class QTBoardRoyal {
    - deckroyal: Deck_Royal
    - grille: QGridLayout
    - ajouterCarte(row: int, col: int): void
    + QTBoardRoyal(parent: QWidget = nullptr)
    + afficher(): void
    + getDeckRoyal(): Deck_Royal*
    + retirerCarte(carte: QTCardRoyal*): void
    + getGrid(): QGridLayout*
    + carteClicked(carte: QTCardRoyal*): void
    + updateAllCardStatus(newStatus: QTCardRoyal::CardRoyalStatus): void
    + acheterCarteClicked(carte: QTCardRoyal*): void
}
}

namespace Sauvegarde {


}
Game "1" -- "2" Player : < joue
Plateau "1" -- "1" GameTable : est joué dans >
Bag "1" -- "1" GameTable : est joué dans >
JewelryCard "*" -- "1" GameTable : est joué dans >
RoyalCard "4" -- "1" GameTable : est joué dans >
GameTable "1" --* Game : se joue dans >
Controller *-- "1" Game : est controllé <

QTGame -- "1" Controller
QTGame -- "1" QTPyramid
QTGame -- "1" QTBoardRoyal
QTGame -- "1" QTRangeePioches


Token "0..25" --* JetonsTotaux : est contenu dans >
Privilege "0..3" --* PrivilegesTotaux : est contenu dans >
Token "0..10" -- "0..1" Player : possède <
Token "0..25" --o "0..1" Bag : est composé de <
Token "0..25" --o "1" Plateau : est placé sur >
Privilege "0..3" --o "0..1" Plateau : est placé sur >

AiStrategy --|> Strategy
HumanStrategy --|> Strategy
Player "1..*" --  "1" Strategy : utilise >

'CoordonneeJeton "0..25" --  "1" Plateau
'CoordonneeJeton "0..1" -- "1" Token

Player "0..1" -- "0..*" JewelryCard : possède >
JewelryCard --* DeckNv1
JewelryCard --* DeckNv2
JewelryCard --* DeckNv3
CartesPyramide *-- "1" DeckNv1
CartesPyramide *-- "1" DeckNv2
CartesPyramide *-- "1" DeckNv3
QTPyramid *-- "0..*" QTCartes
QTRangeePioches *-- "0..*" QTPioche
QTBoardRoyal *-- "0..*" QTCardRoyal
QTCartes -- "1" JewelryCard
QTPyramid -- "1"CartesPyramide
QTCardRoyal -- "1" RoyalCard
QTBoardRoyal -- "1" Deck_Royal
QTPioche -- "1" DeckNv1
QTPioche -- "1" DeckNv2
QTPioche -- "1" DeckNv3


Player "0..1" -- "0..2" RoyalCard : possède >


@enduml

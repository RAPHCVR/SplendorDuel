@startuml
'skinparam classAttributeIconSize 0

enum Niveau <<enumeration >> {
  1
  2
  3
}

struct Bonus {
    couleur : TokenColor
    nombre : uint
}

enum TokenColor <<enumeration >> {
  BLANC
  VERT
  PERLE
  BLEU
  OR
  ROUGE
  NOIR
}
enum OptionalActions{
    UsePrivileges, FillBoard, Empty
}

enum CompulsoryActions{
    TakeCoins, ReserveCard, BuyCard
}

namespace JetonsPrivilegePlateau {

class Token {
   -color : TokenColor
   +Token(token : const Token)
   +Token(color: TokenColor)
   +getColorr() : TokenColor
}

class Privilege{
}

class Bag{
  -tokens : Liste[Token]
  -Bag(total : const TotalTokens)
  -instance : static Bag*
  +getNbToken() : size_t
  +addToken(token : const Token)
  +drawToken() : const Token
  +drawToken(TokenColor color) : const Token
  +isEmpty() const : bool
  +getInstance() : Bag
  +containsOnly(color : TokenColor) : bool
  + resetInstance():static void 
}
note bottom of Bag : Le sac de jeton est unique, pas de duplication

class TotalTokens{
   -tokens : Liste[Token]
   -max_or : const size_t
   -max_rouge : const size_t
   -max_noir : const size_t
   -max_bleu : const size_t
   -max_perle : const size_t
   -max_vert : const size_t
   -max_blanc : const size_t
   {fi+TotalTokens()
   - TotalTokens()
   - ~TotalTokens()
   +getNbToken : size_t
   + getToken(size_t i) const : const Token&
   + getInstance() :const static TotalTokens& 
}
note bottom of TotalTokens: Le total initial est unique, pas de duplication

class TotalPrivileges{
   -privileges : Liste[Privilege]
   -TotalPrivileges()
   -~TotalPrivileges()
   +getNbPrivileges() : size_t
   +getPrivilege() : const Privilege
   +getInstance() : TotalPrivilege
}
note bottom of TotalPrivileges: pas de duplication du total

class Board{
   - tokens : Liste[Liste[Token]]
   - privileges : Liste[Privilege]
   + Board(bag: Bag, privileges: const TotalPrivileges)
   + takeToken(i : size_t, j : size_t) : const Token
   + showBoard()
   + takePrivilege() : const Privilege
   + placeToken(token : const Token)
   + placePrivilege(privilege : const Privilege)
   + fillBoard(bag: Bag)
   + isEmpty() : bool
   + isCellEmpty(size_t i, size_t j) const : bool
   + getInstance() : Board
   + class PlateauIterateur
   + containsOnly(TokenColor color) : bool
   + CellColor(size_t i, size_t j, TokenColor color) const : bool
   + getNbTokens() const : int
   + takeToken(size_t i, size_t j) : const Token&
   + resetInstance() : void

}
note bottom of Board: pas de duplication du plateau


' struct TupleIntJeton {
'   nombre : int
'   type_jeton : Token
' }

'class CoordonneeJeton{
'  x : int
'  y : int
'}
}

enum Abilities <<enumeration >> {
  repeat_turn
  cameleon
  take_bonus_token
  take_privilege
  steal_token
  None
}
namespace GestionPartie{

class Controller {
  - Game : Game*
  - currentPlayer : Player*

  +Controller(const std::string& statut_partie, std::string pseudo1, std::string pseudo2, Type type1, Type type2)
  +~Controller() 
  +getGame() : Game&
  +getcurrentPlayer() : Player&
  +getopposingPlayer() : Player&
  +setCurrentPlayer(unsigned int n): void
  +play(): void
  +playTurn(): void
  +changeCurrentPlayer() : void

  + getOptionalActions(const Game& game, Player& player) const : Liste[OptionalActions]
  + getCompulsoryActions(const Game& game, Player& player) const : Liste[CompulsoryActions]
  + applyOptionalAction(Game& game, Player& player,  OptionalActions action):void
  + applyCompulsoryAction(Game& game, Player& player,  CompulsoryActions action):void
  + applyCardSkills(Game& game, Player& cardOwner, Player& opponent, JewelryCard& card):void
  + applyRoyalCardSkills(Game&game, Player&cardOwner, Player&opponent, RoyalCard&card):void
  + checkCardPurchase(const JewelryCard& card, GameTable& gametable) : bool
  + usePriviledge(Board& board):void
  + fillBoard(Board& board, Bag& bag):void

  + buyNobleCard () :void
  + buyJewelryCard(GameTable& gametable):void
  + bookCard(Pyramid_Cards& pyramid, GameTable& gametable):void
  + checkIfPlayerWins(Game& game, Player& player) :bool

  + saveGame() :void
  + saveScore():void
  + reinit():void
}			 
class Game{
    - round :  int
    -GameTable : GameTable
    - players[2] : Player*
    + Game() 
    + ~Game() 
    + getRound() const : int 
    + getGameTable() const :GameTable&
    +  getPlayer(size_t i) const : Player*
    + setPlayer1(Player *j):void
    + setPlayer2(Player *j):void
    + setRound(unsigned int n) : void
    + roundIncrement() : void
}
class GameTable{
  - deckroyal : Deck_Royal*
  - decklv1 :Deck_level_one* 
  - decklv2 : Deck_level_two*
  - decklv3 :Deck_level_three*
  - pyramid :Pyramid_Cards*
  - bag : Bag*
  - board : Board *

  + GameTable()
  + ~GameTable()
  + getBag() const : Bag 
  +  getBoard() const : Board
  + getPyramid() const : Pyramid_Cards
  + getDeckRoyal() const : Deck_Royal
  + getDeckLevelOne() const : Deck_level_one
  + getDeckLevelTwo() const :Deck_level_two
  + getDeckLevelThree() const :Deck_level_three
}

class QTGame {
    - controller: Controller*
    - plateView: PlateView*
    - pyramid: QTPyramid*
    - pioches: QTRangeePioches*
    - boardRoyal: QTBoardRoyal*
    - privilegeCounter: PrivilegeCounter*
    - mainlayout: QVBoxLayout*
    - screen: QScreen*
    - size: QSize*
    - player1: PlayerQT*
    - player2: PlayerQT*
    - width: unsigned int
    - height: unsigned int
    - status: std::string
    + quit(): void
    + paintEvent(event: QPaintEvent*): void
    + QTGame(parent: QWidget = nullptr)
    + handleTokenSelection(tokens: std::vector<const Token*>): void
    + fillBoard(): void
    + takePrivilege(player: Player&): void
    + bookCard(gametable: GameTable&): void
    + usePriviledge(): void
    + placePrivilege(nb: unsigned int): void
    + applyOptionalAction(action: OptionalActions): void
    + play(): void
    + playOptionalActions(): void
    + handleGameStatus(): void
    + playCompulsoryActions(): void
    + applyCompulsoryAction(action: CompulsoryActions): void
    + checkEndTurn(): void
    + applyCardSkills(game: Game, cardOwner: Player, opponent: Player, card: JewelryCard): void
    + buyJewelryCard(gametable: GameTable): void
    + buyNobleCard(): void
    + applyRoyalCardSkills(game: Game, cardOwner: Player, opponent: Player, card: RoyalCard): void
    + setBoldCurrentPlayer(): void
    + generateNewGame(): void
    + getCurrentQTPlayer():PlayerQT* 
    + isCurrentPlayerIA():bool
    + handleIATokenSelection():void 
    + handleBuyingJewelryCard(cardclicked: Carte*): void
    + handleBookingJewelryCardFromPyramid(clickedCard: Carte*): void
    + handleBookingJewelryCardFromPioche(piocheclicked: QTPioche*): void
    + handleBuyingRoyalCard(cardclicked: QTCardRoyal*): void
    + handleBuyingReserveCard(clickedCard: JewelryCard*): void
}

class QTStartingMenu {
    - playerName1: QString
    - playerName2: QString
    + QTStartingMenu(parent: QWidget = nullptr)
    + getPlayerName1(): QString
    + getPlayerName2(): QString
    + getPlayerType1() : Type
    + getPlayerType2() : Type
    + isLoad() : bool
    + startNewGame(): void
    + loadGame(): void
    + quitGame(): void
    + showScoreBoard() : void
}



}
namespace JoueurHumainIA {

enum Type <<enumeration >> {
  IA
  Humain
}

class Player {
  - name : string
  - privileges : Liste[Privilege*]
  - type : Type
  - nbCrown : int
  - prestigePoints : int
  - nbTokens : int
  - jewelryCards : Liste[JewelryCard*]
  - reserve : Liste[JewelryCard*]
  - royalCards : Liste[RoyalCard*]
  - tokens: unordered_map[int, [Liste[const Token*]]
  - tokenSummary: unordered_map[TokenColor, int]
  - blueSummary: SummaryCard
  - greenSummary: SummaryCard
  - redSummary: SummaryCard
  - whiteSummary: SummaryCard
  - blackSummary: SummaryCard
  - strategy : Strategy*

  + getName() : string
  + getNbPrivilege() const : int
  + getNbTokens() const : int
  + getTokenSummary(): unordered_map<TokenColor, int>
  + getBonusSummary() : vector
  + getColorSummary() : SummaryCard&
  + getWhiteSummary():SummaryCard&
  + getGreenSummary():SummaryCard&
  + getBlackSummary():SummaryCard&
  + getRedSummary() :SummaryCard&
  + getMaxPrestigeColor() : int
  + getPrivilege() : int
  + getPrestige() : int
  + getCrowns() : int
  + getTokens() : int
  + getType() : Type
  + addToken(Token token)
  + removeToken(Token token)
  + addCrowns()
  + addPrestige(int nb, TokenColor couleur)
  + addPrivilege(const Privilege& privilege)
  + removePrivilege()
  + addJewelryCard(JewelryCard card)
  + addRoyalCard(RoyalCard card)
  + actionAddToken()
  + actionReserveCard()
  + actionBuyCard()
  + actionBuyReservedCard(JewelryCard &card)											
  + canBuyCard(const JewelryCard &card): Bool
  + spendResources(const JewelryCard &card)
  + usePrivilege()
  + reserveoneCard (JewelryCard& card)
  + canReserveCard()									  
  + actionFillBoard()
  + canbuyreservedcard() : bool
  + spendGoldTokens(int number) : void
  + spendSpecificToken(TokenColor color, int number) : void
  + toString(Type t) : string
  + toType(string s) : Type
  + operator<<(std::ostream& f, Player& p) : ostream&
  + getStrategy() : Strategy*
}
note bottom of Player : privilege entre 0 et 3


class Strategy

class AiStrategy{
    + choicemaker(int min, int max) : int 
    + choseOptionalActions() : std::vector<OptionalActions> 
    + choseCompulsoryAction() : CompulsoryActions 
    + choseTokensToTake() : std::vector<std::pair<int, int>> 
    + choseTokenColor(std::vector<TokenColor>& chosableColors) : TokenColor 
    + chooseToken(Board&board,Player &player, std::vector<std::pair<int, int>>* tokenIndexes=nullptr) : const Token&
    + chooseGoldenToken(Board&board, Player&player): void 

}

class HumanStrategy{
    + choicemaker(int min, int max) : int 
    + choseOptionalActions() : std::vector<OptionalActions> 
    + choseCompulsoryAction() : CompulsoryActions 
    + choseTokensToTake() : std::vector<std::pair<int, int>> 
    + choseTokenColor(std::vector<TokenColor>& chosableColors) : TokenColor 
    + chooseToken(Board&board,Player &player, std::vector<std::pair<int, int>>* tokenIndexes=nullptr) : const Token&
    + chooseGoldenToken(Board&board, Player&player): void 

}


}

namespace GestionCartes{


class SummaryCard{
  - unsigned int prestigePoints;
  - unsigned int bonusNumber;
  + explicit SummaryCard(unsigned int p = 0, unsigned int b = 0)
  + getPrestigePoints():unsigned int
  + getBonusNumber() :unsigned int
  + addBonusNumber(unsigned int b) :void
  + addprestigePoints(unsigned int p):void
}


class JewelryCard <<abstract>>{
  - level : unsigned int 
  - cost : unordered_map<TokenColor, int>  
  - prestige_points : unsigned int
  - crowns :unsigned int
  - ability1 :Abilities
  - ability2 :Abilities
  - bonus:Bonus
	- id : int 

  + JewelryCard(unsigned int l, unordered_map<TokenColor, int> c, unsigned int pp, unsigned int cr, Abilities a1, Abilities a2, Bonus b, int i)
  + getLevel() : int
  + getCost() : unordered_map<TokenColor, int> 
  + getPrestige() : int
  + getCrowns() : int
  + getAbility1()  : Abilities
  + getAbility2() : Abilities
  +  getBonus() :Bonus
	+ getId() : int
  + operator==(const JewelryCard& other) const : bool 

}

note bottom of JewelryCard : point de prestige entre 0 et 4\ncouronne entre 0 et 2


class RoyalCard {
  - prestige_points :unsigned int 
  - ability :Abilities
  - id :unsigned int

  + RoyalCard(unsigned int pp, Abilities a, unsigned int i)
  + getPrestige():unsigned int 
  + getAbility():Abilities 
  + getId():unsigned int 
  				
}

note bottom of RoyalCard :  point de prestige 2 ou 3\ncouronnes nécessaire entre 3 ou 6
note bottom of RoyalCard : Une classe RoyalCardError est présente pour spécifier les erreurs

class Deck_Royal{
  - Deck_Royal()
  - instance : static Deck_Royal*
  - cards : vector[RoyalCard*]
  + getInstance : Deck_Royal
  + getInstance(const std::string& databaseSavePath):static Deck_Royal*
  + getCards : vector[RoyalCard]
  + addCardToDeck(card : RoyalCard*) : void
  + deleteCard(pos : int) : void
  + resetInstance() : static void
}
note bottom of Deck_Royal : Gère le deck des cartes royales

class Deck_level_one{
  - Deck_level_one()
  - Deck_level_one(const std::string& databaseSavePath)
  - instance : Deck_level_one *
  - pioche : Liste[RoyalCard*]
  + getInstance() : Deck_level_one*
  + getInstance(const std::string& databaseSavePath) : Deck_level_one*
  + getPioche() : Liste[RoyalCard*]
  + addCardToDeck(card : RoyalCard*) : void
  + deleteFirstItem() : void
  + resetInstance(): static void
}

class Deck_level_two{
  - Deck_level_two()
  - Deck_level_two(const std::string& databaseSavePath)
  - instance : Deck_level_two* 
  - pioche : Liste[RoyalCard*]
  + getInstance() : Deck_level_two*
  + getInstance(const std::string& databaseSavePath) : Deck_level_two*
  + getPioche() : Liste[JewelryCard*]
  + addCardToDeck(card : JewelryCard*) : void
  + deleteFirstItem() : void
  + resetInstance(): static void
}

class Deck_level_three{
  - Deck_level_three()
  - Deck_level_three(const std::string& databaseSavePath)
  - instance : Deck_level_three *
  - pioche : Liste[RoyalCard*]
  + getInstance() : Deck_level_three*
  + getInstance(const std::string& databaseSavePath) : Deck_level_three*
  + getPioche() : Liste[JewelryCard*]
  + addCardToDeck(card : JewelryCard*) : void
  + deleteFirstItem() : void
  + resetInstance(): static void
}

class Pyramid_Cards{
    - instance : Pyramid_Cards
    - row_level_one : Liste[JewelryCard]
    - row_level_two : Liste[JewelryCard]
    - row_level_three : Liste[JewelryCard]
    - max_level_one : static int
    - max_level_two : static int
    - max_level_three : static int

    + Pyramid_Cards(const std::string & databaseSavePath)
    + getInstance() :static Pyramid_Cards* 
    + getInstance(const std::string& databaseSavePath) :static Pyramid_Cards* 
    + resetInstance() :static void 
    + void drawCard(unsigned int level);
    + takeCard(unsigned int level, unsigned int position) :JewelryCard& 
    + getRow1() : vector<JewelryCard*>
    + getRow2() : vector<JewelryCard*>
    + getRow3() : vector<JewelryCard*>
    + isEmpty(unsigned int level) : bool
    + getLevelCards(unsigned int i) : vector<JewelryCard*> 

}
}


Game "1" -- "2" Player : < joue
Board "1" -- "1" GameTable : est joué dans >
Bag "1" -- "1" GameTable : est joué dans >
JewelryCard "*" -- "1" GameTable : est joué dans >
RoyalCard "4" -- "1" GameTable : est joué dans >
GameTable "1" --* Game : se joue dans >
Controller *-- "1" Game : est controllé <




Token "0..25" --* TotalTokens : est contenu dans >
Privilege "0..3" --* PrivilegesTotaux : est contenu dans >
Token "0..10" -- "0..1" Player : possède <
Token "0..25" --o "0..1" Bag : est composé de <
Token "0..25" --o "1" Board : est placé sur >
Privilege "0..3" --o "0..1" Board : est placé sur >

AiStrategy --|> Strategy
HumanStrategy --|> Strategy
Player "1..*" --  "1" Strategy : utilise >



Player "0..1" -- "0..*" JewelryCard : possède >
JewelryCard --* Deck_level_one
JewelryCard --* Deck_level_two
JewelryCard --* Deck_level_three
Pyramid_Cards *-- "1" Deck_level_one
Pyramid_Cards *-- "1" Deck_level_two
Pyramid_Cards *-- "1" Deck_level_three


Player "0..1" -- "0..2" RoyalCard : possède >


@enduml
